# FuLang — Мини-фреймворк интерпретатора функционального языка

Этот пакет реализует интерпретатор минималистичного функционального языка с возможностью:

- вызова функций по заданной грамматике
- поддержки вложенных выражений
- использования аргументов
- добавления собственных функций
- запуска интерактивной REPL-оболочки

> ⚠️ Требуемая версия PHP: **>= 8.0**

---

## Установка

```bash
git clone https://github.com/Troum/fu-lang.git
cd fu-lang
composer install
```

---

## Поддерживаемый синтаксис

Программа — это одно выражение:

```
<выражение> ::= <вызов_функции> | <константа>
<вызов_функции> ::= '(' <имя> ')' | '(' <имя>, <аргументы> ')'
<аргументы> ::= <выражение> | <выражение>, <аргументы>
<константа> ::= "строка" | число | true | false | null
```

---

## Быстрый запуск

Файл `bin/run.php` запускает фиксированную программу с аргументами (из тестового задания):

```bash
php bin/run.php world
```

Выход:

```
{"message":"Hello, world"}
```

---

## Интерактивный режим (REPL)

```bash
php bin/repl.php
```

> Можно использовать REPL для отладки и экспериментов с языком.

### Примеры:

```lisp
> :setarg 0 мир
> (concat, "Привет, ", (getArg, 0))
Привет, мир

> (array, 1, 2, 3)
[1, 2, 3]

> (map, (array, "ключ"), (array, "значение"))
{
  "ключ": "значение"
}
```

---

## Поддерживаемые встроенные функции

| Имя функции | Описание                                           |
|-------------|----------------------------------------------------|
| `getArg(N)` | Получает аргумент по индексу                       |
| `array(...)` | Возвращает массив                                  |
| `map(keys, values)` | Создает ассоциативный массив                       |
| `json(value)` | Создает JSON-представление                         |
| `concat(a, b)` | Соверщает конкатенация строк                       |
| `upper(string)` | Производит преобразование строки в верхний регистр |
| `lower(string)` | Производит преобразование строки в нижний регистр                    |

---

## Добавление пользовательских функций

Для добавления пользовательских функций, добавьте в своем коде:

```php
$interpreter->addFunction('strlen', fn($s) => strlen($s));
```

Далее можно использовать в выражениях (пример ниже):

```lisp
(strlen, "Привет")
```

---

## Команды REPL

| Команда        | Назначение                      |
|----------------|---------------------------------|
| `:setarg N V`  | Установить аргумент по индексу |
| `:args`        | Показать текущие аргументы     |
| `:reset`       | Сбросить все аргументы         |
| `:exit`        | Завершить REPL                 |
| `:help`        | Показать справку               |

---

## Пример использования в коде

```php
use FunctionalLang\Core\Parser;
use FunctionalLang\Core\Interpreter;

$parser = new Parser('(upper, (concat, "Привет, ", (getArg, 0)))');
$ast = $parser->parse();

$interpreter = new Interpreter();
$interpreter->addDefaultFunctions();
$result = $interpreter->eval($ast, ['мир']);

echo $result;
```

```lisp
ПРИВЕТ, МИР
```

---

## Автозагрузка и совместимость

Фреймворк использует PSR-4 и работает на **PHP >= 8.0**.  
Для автоматической загрузки:

```bash
composer dump-autoload
```

---

## Автор

Разработано для тестового задания.